fn main() {
    println!("{}", "=== Basic numeric conversions ===".to_string());
    let mut i = 42;
    let mut f = float64(i);
    let mut i2 = int(f);
    print!("int: {}\n", i);
    print!("float64: {:.2}\n", f);
    print!("back to int: {}\n", i2);
    println!("{}", "\n=== Integer size conversions ===".to_string());
    let mut i8 = 127;
    let mut i16 = int16(i8);
    let mut i32 = int32(i16);
    let mut i64 = int64(i32);
    print!("int8: {}\n", i8);
    print!("int16: {}\n", i16);
    print!("int32: {}\n", i32);
    print!("int64: {}\n", i64);
    println!("{}", "\n=== Unsigned integer conversions ===".to_string());
    let mut ui = 42;
    let mut ui8 = uint8(ui);
    let mut ui16 = uint16(ui8);
    let mut ui32 = uint32(ui16);
    let mut ui64 = uint64(ui32);
    print!("uint: {}\n", ui);
    print!("uint8: {}\n", ui8);
    print!("uint16: {}\n", ui16);
    print!("uint32: {}\n", ui32);
    print!("uint64: {}\n", ui64);
    println!("{}", "\n=== Float conversions ===".to_string());
    let mut f64 = 3.14159265359;
    let mut f32 = float32(f64);
    let mut backToF64 = float64(f32);
    print!("float64: %.10f\n", f64);
    print!("float32: %.10f\n", f32);
    print!("back to float64: %.10f\n", backToF64);
    println!("{}", "\n=== String conversions ===".to_string());
    let mut r = 'A';
    let mut b = 65;
    print!("rune 'A': %c ({})\n", r, r);
    print!("byte 65: %c ({})\n", b, b);
    let mut str = string(r);
    print!("rune to string: {}\n", str);
    let mut bytes = vec![72, 101, 108, 108, 111];
    let mut strFromBytes = string(bytes);
    print!("bytes to string: {}\n", strFromBytes);
    let mut backToBytes = (strFromBytes);
    print!("string to bytes: {}\n", backToBytes);
    let mut runes = ("Hello, 世界".to_string());
    print!("string to runes: {}\n", runes);
    print!("rune count: {}\n", runes.len());
    let mut backToString = string(runes);
    print!("runes to string: {}\n", backToString);
    println!("{}", "\n=== Boolean-like conversions ===".to_string());
    let mut zero = 0;
    let mut nonZero = 42;
    print!("zero == 0: {}\n", zero == 0);
    print!("nonZero != 0: {}\n", nonZero != 0);
    println!("{}", "\n=== Pointer conversions ===".to_string());
    let mut num = 100;
    let mut ptr = &num;
    print!("value: {}\n", num);
    print!("pointer: %p\n", ptr);
    print!("dereferenced: {}\n", );
    println!("{}", "\n=== Interface conversions ===".to_string());
    let mut any = 42;
    print!("interface{} value: {}\n", any);
    print!("interface{} type: %T\n", any);
    let (mut intVal, mut ok) = match any.downcast_ref::<i32>() { Some(v) => (v.clone(), true), None => (0, false) };
    if ok {
        print!("asserted as int: {}\n", intVal);
    }
    any = "hello".to_string();
    print!("new interface{} value: {}\n", any);
    print!("new interface{} type: %T\n", any);
    let (mut strVal, mut ok) = match any.downcast_ref::<String>() { Some(v) => (v.clone(), true), None => (String::new(), false) };
    if ok {
        print!("asserted as string: {}\n", strVal);
    }
    println!("{}", "\n=== Complex number conversions ===".to_string());
    let mut c64 = 3 + 4i;
    let mut c128 = complex128(c64);
    print!("complex64: {}\n", c64);
    print!("complex128: {}\n", c128);
    let mut real = real(c128);
    let mut imag = imag(c128);
    print!("real part: {:.2}\n", real);
    print!("imaginary part: {:.2}\n", imag);
    let mut newComplex = complex(real, imag);
    print!("reconstructed: {}\n", newComplex);
    println!("{}", "\n=== Overflow examples ===".to_string());
    let mut bigInt = 1000000;
    let mut smallInt = int8(bigInt);
    print!("int64: {}\n", bigInt);
    print!("int8 (overflow): {}\n", smallInt);
    let mut preciseFloat = 1.23456789012345;
    let mut lessPrec = float32(preciseFloat);
    print!("float64: %.15f\n", preciseFloat);
    print!("float32: %.15f\n", lessPrec);
    println!("{}", "\n=== Custom type conversions ===".to_string());
    
    
    let mut mi = 42;
    let mut regularInt = int(mi);
    let mut backToMyInt = my_int(regularInt);
    print!("MyInt: {}\n", mi);
    print!("regular int: {}\n", regularInt);
    print!("back to MyInt: {}\n", backToMyInt);
    let mut ms = "hello".to_string();
    let mut regularString = string(ms);
    let mut backToMyString = my_string(regularString);
    print!("MyString: {}\n", ms);
    print!("regular string: {}\n", regularString);
    print!("back to MyString: {}\n", backToMyString);
}