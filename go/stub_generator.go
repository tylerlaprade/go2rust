package main

import (
	"fmt"
	"go/ast"
	"os"
	"path/filepath"
	"strings"
)

// StubGenerator generates stub implementations for external packages
type StubGenerator struct {
	projectPath    string
	packageMapping map[string]string // Maps Go import path to Rust crate name
	generatedStubs map[string]bool   // Track which stubs have been generated
}

// NewStubGenerator creates a new stub generator
func NewStubGenerator(projectPath string) *StubGenerator {
	return &StubGenerator{
		projectPath:    projectPath,
		packageMapping: make(map[string]string),
		generatedStubs: make(map[string]bool),
	}
}

// GenerateStubsFromImports generates stub modules for all external imports in the given AST files
func (sg *StubGenerator) GenerateStubsFromImports(astFiles []*ast.File) error {
	// Collect all external imports
	externalImports := make(map[string]string) // import path -> package name

	for _, file := range astFiles {
		for _, imp := range file.Imports {
			importPath := strings.Trim(imp.Path.Value, `"`)
			if isStdlibPackage(importPath) {
				continue
			}

			// Determine package name
			var pkgName string
			if imp.Name != nil {
				pkgName = imp.Name.Name
			} else {
				// Use last segment of import path
				segments := strings.Split(importPath, "/")
				pkgName = segments[len(segments)-1]
			}

			externalImports[importPath] = pkgName
		}
	}

	// Generate stub for each external package
	for importPath, pkgName := range externalImports {
		if err := sg.generateStub(importPath, pkgName); err != nil {
			return fmt.Errorf("failed to generate stub for %s: %v", importPath, err)
		}
	}

	return nil
}

// generateStub generates a stub Rust module for an external package
func (sg *StubGenerator) generateStub(importPath, pkgName string) error {
	// Skip if already generated
	if sg.generatedStubs[importPath] {
		return nil
	}

	// Convert import path to Rust crate name
	crateName := sg.goPathToRustCrate(importPath)
	sg.packageMapping[importPath] = crateName

	// Create external_stubs directory
	vendorDir := filepath.Join(sg.projectPath, "external_stubs")
	if err := os.MkdirAll(vendorDir, 0755); err != nil {
		return fmt.Errorf("failed to create external_stubs directory: %v", err)
	}

	// Create package directory
	pkgDir := filepath.Join(vendorDir, crateName)
	if err := os.MkdirAll(pkgDir, 0755); err != nil {
		return fmt.Errorf("failed to create package directory: %v", err)
	}

	// Generate lib.rs with TODO comments (only if it doesn't exist)
	libRsPath := filepath.Join(pkgDir, "lib.rs")
	if _, err := os.Stat(libRsPath); os.IsNotExist(err) {
		libRsContent := sg.generateLibRsContent(importPath, pkgName)
		if err := os.WriteFile(libRsPath, []byte(libRsContent), 0644); err != nil {
			return fmt.Errorf("failed to write lib.rs: %v", err)
		}
		fmt.Fprintf(os.Stderr, "Generated NEW stub for %s at external_stubs/%s/\n", importPath, crateName)
	} else {
		fmt.Fprintf(os.Stderr, "Using existing stub for %s at external_stubs/%s/\n", importPath, crateName)
	}

	// Generate Cargo.toml
	cargoTomlPath := filepath.Join(pkgDir, "Cargo.toml")
	cargoTomlContent := fmt.Sprintf(`[package]
name = "%s"
version = "0.1.0"
edition = "2021"

[lib]
name = "%s"
path = "lib.rs"

[dependencies]
# TODO: Add any Rust dependencies needed for this package implementation
`, crateName, crateName)

	if err := os.WriteFile(cargoTomlPath, []byte(cargoTomlContent), 0644); err != nil {
		return fmt.Errorf("failed to write Cargo.toml: %v", err)
	}

	sg.generatedStubs[importPath] = true
	return nil
}

// generateLibRsContent generates the content for a stub lib.rs file
func (sg *StubGenerator) generateLibRsContent(importPath, pkgName string) string {
	var content strings.Builder

	content.WriteString("// STUB IMPLEMENTATION - TODO: Implement this external package\n")
	content.WriteString(fmt.Sprintf("// Original Go package: %s\n", importPath))
	content.WriteString(fmt.Sprintf("// Package name: %s\n", pkgName))
	content.WriteString("//\n")
	content.WriteString("// This is a stub implementation generated by go2rust.\n")
	content.WriteString("// You need to manually implement the functionality of this package.\n")
	content.WriteString("//\n")
	content.WriteString("// Tips for implementation:\n")
	content.WriteString("// 1. Check if a Rust equivalent exists (e.g., on crates.io)\n")
	content.WriteString("// 2. Study the Go package documentation and source code\n")
	content.WriteString("// 3. Implement only the functions/types your code actually uses\n")
	content.WriteString("// 4. Consider using FFI to call the original Go library if needed\n")
	content.WriteString("\n")
	content.WriteString("use std::cell::RefCell;\n")
	content.WriteString("use std::rc::Rc;\n")
	content.WriteString("use std::any::Any;\n")
	content.WriteString("\n")
	content.WriteString("// TODO: Add your implementation here\n")
	content.WriteString("//\n")
	content.WriteString("// The transpiled code is trying to use this package.\n")
	content.WriteString("// Look at main.rs to see what functions/types are being called.\n")
	content.WriteString("//\n")
	content.WriteString("// For the shopspring/decimal package, you might want to:\n")
	content.WriteString("// 1. Use the 'rust_decimal' crate from crates.io\n")
	content.WriteString("// 2. Create wrapper types that match the Go API\n")
	content.WriteString("\n")

	// Add special handling for known packages
	if importPath == "github.com/shopspring/decimal" {
		content.WriteString("// Special note for shopspring/decimal:\n")
		content.WriteString("// Consider using the 'rust_decimal' crate: https://crates.io/crates/rust_decimal\n")
		content.WriteString("//\n")
		content.WriteString("// Example implementation skeleton:\n")
		content.WriteString("/*\n")
		content.WriteString("use rust_decimal::Decimal;\n\n")
		content.WriteString("pub struct decimal {\n")
		content.WriteString("    value: Decimal,\n")
		content.WriteString("}\n\n")
		content.WriteString("impl decimal {\n")
		content.WriteString("    pub fn new_from_int(n: Rc<RefCell<Option<i32>>>) -> Rc<RefCell<Option<Self>>> {\n")
		content.WriteString("        let val = *n.borrow().as_ref().unwrap();\n")
		content.WriteString("        Rc::new(RefCell::new(Some(decimal {\n")
		content.WriteString("            value: Decimal::from(val),\n")
		content.WriteString("        })))\n")
		content.WriteString("    }\n\n")
		content.WriteString("    pub fn new_from_float(f: Rc<RefCell<Option<f64>>>) -> Rc<RefCell<Option<Self>>> {\n")
		content.WriteString("        unimplemented!(\"TODO: Implement new_from_float\")\n")
		content.WriteString("    }\n\n")
		content.WriteString("    pub fn div(&self, other: Rc<RefCell<Option<decimal>>>) -> Rc<RefCell<Option<decimal>>> {\n")
		content.WriteString("        unimplemented!(\"TODO: Implement div\")\n")
		content.WriteString("    }\n\n")
		content.WriteString("    pub fn mul(&self, other: Rc<RefCell<Option<decimal>>>) -> Rc<RefCell<Option<decimal>>> {\n")
		content.WriteString("        unimplemented!(\"TODO: Implement mul\")\n")
		content.WriteString("    }\n\n")
		content.WriteString("    pub fn string(&self) -> Rc<RefCell<Option<String>>> {\n")
		content.WriteString("        Rc::new(RefCell::new(Some(self.value.to_string())))\n")
		content.WriteString("    }\n")
		content.WriteString("}\n")
		content.WriteString("*/\n")
	} else {
		content.WriteString("// Generic stub structure (replace with actual implementation):\n")
		content.WriteString("//\n")
		content.WriteString("// pub struct YourType {\n")
		content.WriteString("//     // fields...\n")
		content.WriteString("// }\n")
		content.WriteString("//\n")
		content.WriteString("// impl YourType {\n")
		content.WriteString("//     pub fn new() -> Rc<RefCell<Option<Self>>> {\n")
		content.WriteString("//         unimplemented!(\"TODO: Implement YourType::new\")\n")
		content.WriteString("//     }\n")
		content.WriteString("// }\n")
		content.WriteString("//\n")
		content.WriteString("// pub fn some_function() -> Rc<RefCell<Option<SomeType>>> {\n")
		content.WriteString("//     unimplemented!(\"TODO: Implement some_function\")\n")
		content.WriteString("// }\n")
	}

	return content.String()
}

// goPathToRustCrate converts a Go import path to a Rust-compatible crate name
func (sg *StubGenerator) goPathToRustCrate(goPath string) string {
	// Replace special characters with underscores
	crate := strings.ReplaceAll(goPath, "/", "_")
	crate = strings.ReplaceAll(crate, "-", "_")
	crate = strings.ReplaceAll(crate, ".", "_")

	// Ensure it starts with a letter or underscore
	if len(crate) > 0 && (crate[0] >= '0' && crate[0] <= '9') {
		crate = "_" + crate
	}

	return crate
}

// GetPackageMapping returns the package mapping from Go import paths to Rust crate names
func (sg *StubGenerator) GetPackageMapping() map[string]string {
	return sg.packageMapping
}
